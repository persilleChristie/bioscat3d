#include "../../lib/Forward/MASSystem.h"
#include "../Utils/Constants.h"
#include "../Utils/ConstantsModel.h"
#include "../Utils/UtilsPybind.h"
#include <map>
using std::ignore;

/// @file MASSystem.cpp
/// @brief Implementation of the MASSystem class, which generates a surface system based on a spline and computes auxiliary points.
/// @details This class is used to generate a surface system for the MAS (Metasurface Antenna System) based on a spline object.
/// The surface is generated by sampling points on the spline and calculating normals and tangents.
/// The class also computes auxiliary points for the system, which are used in further calculations.
MASSystem::MASSystem(const py::object spline, const double dimension,
                        const Eigen::Vector3d& kinc, const Eigen::VectorXd& polarizations)
    : kinc_(kinc), polarizations_(polarizations)
    {
        generateSurface(spline, dimension);
    }

    /// @brief Generates the surface points, normals, and tangents based on the provided spline object.
    /// @param spline A Python object representing the spline surface (must expose `max_curvature` and be callable).
    /// @param dimension The physical dimension (width) of the surface domain.
    /// @details This method generates the surface points, normals, and tangents by calling the spline object with a specified resolution.
    void MASSystem::generateSurface(const py::object spline, const double dimension){

        auto alpha = constantsModel.getAlpha();
        auto auxpts_pr_lambda = constantsModel.getAuxPtsPrLambda();

        std::cout << "Generating surface" << std::endl;

        const double maxcurvature = spline.attr("max_curvature").cast<double>();
        std::cout << "Max curvature: " << maxcurvature << std::endl;

        // --------- Generate test points -----------
        const double lambda = constants.getWavelength();
        const int test_point_res = static_cast<int>(std::ceil(sqrt(2) * auxpts_pr_lambda * dimension/lambda));

        // Calculate points on surface and translate to Eigen
        const auto result = PybindUtils::call_spline(spline, test_point_res);
        
        // Save in class
        this->points_ = result[0];
        this->normals_ = result[1];
        this->tau1_ = result[2];
        this->tau2_ = result[3];

        // Calculate control points on surface and translate to Eigen
        const auto control_result = PybindUtils::call_spline(spline, 3*test_point_res);

        this->control_points_ = control_result[0];
        this->control_tangents1_ = control_result[2];
        this->control_tangents2_ = control_result[3];


        // --------- Generate auxiliary points -----------
        const int aux_points_res = std::ceil(auxpts_pr_lambda * dimension/lambda);

        // Calculate points on surface and translate to Eigen
        const auto result_aux = PybindUtils::call_spline(spline, aux_points_res);
        
        // Calculate point values and save in class
        // radius = 1/max(maxcurvature, 1.0)
        double radius;
        if (constantsModel.getFixedRadius() > 0) {
            radius = constantsModel.getFixedRadius();
        }
        else {
            std::cout << "Using max curvature to calculate radius: " << radius << std::endl;
            radius = 1.0/std::max(maxcurvature, 0.1);
        }

        std::cout << "Radius: " << radius << std::endl;

        this->aux_points_int_ = result_aux[0] - ((1 - alpha) * radius) * result_aux[1]; 
        this->aux_points_ext_ = result_aux[0] + ((1 - alpha) * radius) * result_aux[1];

        this->aux_normals_ = result_aux[1];
        this->aux_tau1_ = result_aux[2];
        this->aux_tau2_ = result_aux[3];
}